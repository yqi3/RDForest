######################################
# Figure 1: Densities of the Collapsed
# Bivariate Scores
######################################
rm(list=ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(ggplot2)
library(gridExtra)
library(foreign)
set.seed(0)
source("../../Data/Keele & Titiunik 2015/KeeleTitiunik2014-PA-replication-files/Analysis/Local Poly/distance-functions.R")
source("../../Helper Fns/KT_Helper_Fns.R")

#### Load WGAN data & specify polynomial DGP ####
### True density of the transformed bivariate score (using signed Euclidean distance) when both X1 and X2 are distributed uniform[-1, 1]
true_density <- function(x){
  f <- NULL
  f[x>=-1 & x<=0] <- (abs(x[x>=-1 & x<0])*pi/2)*3/4
  f[x >= -sqrt(2) & x < -1] <- (-abs(x[x >= -sqrt(2) & x < -1])*(asin(sqrt(x[x >= -sqrt(2) & x < -1]^2-1)/abs(x[x >= -sqrt(2) & x < -1]))-asin(1/abs(x[x >= -sqrt(2) & x < -1]))))*3/4
  f[x>=0 & x<=1] <- (x[x>=0 & x<=1]*pi/2)/4
  f[x>1 & x<=sqrt(2)] <- x[x>1 & x<=sqrt(2)]*(asin(1/x[x>1 & x<=sqrt(2)])-asin(sqrt(x[x>1 & x<=sqrt(2)]^2-1)/x[x>1 & x<=sqrt(2)]))/4
  f
}

### WGAN-generated data trained using the the Keele & Titiunik (2015) dataset
sample_WGAN <- read.csv("../../Data/Keele & Titiunik 2015/WGAN_Epoch1k/price_cWGAN.csv")
colnames(sample_WGAN) <- c("price", "latitude", "longitude", "treat")

### Data generated by the polynomial specification
library(haven)
data <- read_dta("../../Data/Keele & Titiunik 2015/KeeleTitiunik2014-PA-replication-files/Data/Housing/NJ_House_Final.dta")
data <- data[complete.cases(data$latitude, data$longitude, data$treat, data[,c("sqft_price")]),]

# Points on the treatment boundary
pointsALL <- read.dbf("../../Data/Keele & Titiunik 2015/KeeleTitiunik2014-PA-replication-files/Data/BorderSegmentPoints_Project.dbf") # boundary data
pointsALL$latitude= pointsALL$POINT_Y
pointsALL$longitude= pointsALL$POINT_X
focal <- matrix(c(pointsALL$latitude[45],pointsALL$longitude[45]),nrow = 1) # this is the "cutoff" point of interest

X1 <- data$latitude
X2 <- data$longitude
mean_X1 <- mean(X1)
mean_X2 <- mean(X2)
price <- data$sqft_price

# Train the polynomial model
model.df <- data.frame(Y=price, 
                       X1=X1, 
                       X1.2=(X1 - mean_X1)^2, 
                       X1.3=(X1 - mean_X1)^3,
                       X2=X2, 
                       X2.2=(X2 - mean_X2)^2, 
                       X2.3=(X2 - mean_X2)^3,
                       X12=(X1 - mean_X1)*(X2 - mean_X2),
                       W=data$treat)

cef <- lm(Y ~ W * ., data = model.df)
sigma_y <- sqrt(summary(cef)$sigma^2)

# Genearte sample data from the polynomial DGP
sample_poly <- genDGP(n=1e6, outcome="price")  # this may several minutes

# calculate the signed chordal distance as in Keele & Titiunik (2015)
for (dgp in c("WGAN", "poly")){
  datause <- eval(as.symbol(paste0("sample_", dgp)))
  
  # ---- the code below this line of comment is adapted from Keele & Titiunik (2015) ----
  
  ## Get covariates: latitude and longitude
  x1 <- datause$latitude
  x2 <- datause$longitude
  
  # Get outcome
  y <- datause$price
  treat <- datause$treat
  
  ## Set up treated data
  indx = (treat == 1)
  x1.Tr <- x1[indx]
  x2.Tr <- x2[indx]
  y.Tr  <- y[indx]
  
  ## Set up control data
  indx = (treat == 0)
  x1.Co <- x1[indx]
  x2.Co <- x2[indx]
  y.Co  <- y[indx]
  
  # calculate chordal distance between each (x1,x2) latitude-longitude pair in the data and the point of the boundary (b1,b2) where we are evaluating
  b1 = focal[1] # latitude
  b2 = focal[2] # longitude
  outdis = disvec(lat1=b1, lon1=b2, lat2 = x1.Tr, lon2 = x2.Tr)
  disTr = as.vector(outdis$chord)

  outdis = disvec(lat1=b1, lon1=b2, lat2 = x1.Co, lon2 = x2.Co)
  disCo= as.vector(outdis$chord)
  
  assign(paste0("score_", dgp), c(disTr, -disCo))
  # ---- the code above this line of comment is adapted from Keele & Titiunik (2015) ----
}


#### Plot (actual, WGAN 1k epoch, poly) ####
# For the true density, sample X1 and X2 from unif[-1,1]
mydata <- data.frame(cbind("X1"=runif(10000, -1, 1),
                           "X2"=runif(10000, -1, 1)))
# Treated if X1 > 0 and X2 >0
mydata$treat <- ifelse(mydata$X1 > 0 & mydata$X2 > 0, 1, 0)
# Collapse the score to a univariate variable based on signed Euclidean distance
collapsed_score <- ifelse(mydata$treat==1, sqrt(mydata$X1^2+mydata$X2^2), -sqrt(mydata$X1^2+mydata$X2^2))
collapsed_score <- as.data.frame(collapsed_score)

p1 <- ggplot(as.data.frame(collapsed_score), aes(collapsed_score))+
  geom_area(stat="function", 
            fun=true_density, 
            color="blue",
            fill="lavender",
            alpha=0.5)+
        theme_bw(base_size = 16)+
        ylab("Density")+
        xlab("Signed Euclidean Distance to (0,0)")+
  ggtitle("True Density (Bivariate Uniform)")+
  theme(plot.title = element_text(size = 18),
        axis.title=element_text(size=14))

p2 <- ggplot(as.data.frame(score_WGAN), aes(score_WGAN))+
  geom_histogram(bins=10000,
                 color="blue", 
                 fill="lavender",
                 alpha=0.5,
                 linewidth=0.005)+
  theme_bw(base_size = 16)+
  ylab("Count")+
  xlab("Signed Chordal Distance to Boundary Point")+
  ggtitle("Histogram (WGAN)")+
  theme(plot.title = element_text(size = 18),
        axis.title=element_text(size=14))

p3 <- ggplot(as.data.frame(score_poly), aes(score_poly))+
  geom_histogram(bins=10000,
                 color="blue", 
                 fill="lavender",
                 alpha=0.5,
                 linewidth=0.005)+
  theme_bw(base_size = 16)+
  ylab("Count")+
  xlab("Signed Chordal Distance to Boundary Point")+
  ggtitle("Histogram (Polynomial)")+
  theme(plot.title = element_text(size = 18),
        axis.title=element_text(size=14))

fig1 <- arrangeGrob(p1, p2, p3, ncol=3)
ggsave("fig-dens-collapsed-scores.png", fig1, width = 16, height = 5)
