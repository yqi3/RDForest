######################################
# Helper functions for Keele & Titiunik (2015)
######################################
set.seed(1234)
library(dplyr)
library(DiceKriging)

#### Coin flip function according to predicted probability ####                                                                                                                                 
bern <- function(prob) {
  return(as.numeric(rbernoulli(n=1,p=prob)))
}


#### Function that ensures bounded noise generated by rnorm() in genDGP ####
bounded_noise <- function(noise) {
  return(max(min(noise,10),-10))
}

### Generate simulation data ###
#### genDGP is a function that generates simulation data given sample size n and desired outcome variable ####
genDGP <- function(n, outcome){
  
  # Restrict range
  rand <- sample_n(data[data$latitude>=min(pointsALL$latitude) & data$latitude<=max(pointsALL$latitude) & data$longitude>=min(pointsALL$longitude) & data$longitude<=max(pointsALL$longitude), ], n, replace=TRUE)
  latitude <- rand$latitude+sapply(rnorm(n, 0, sd=0.01), FUN=bounded_noise)
  longitude <- rand$longitude+sapply(rnorm(n, 0, sd=0.01), FUN=bounded_noise)
  
  simdata <- as.data.frame(cbind("latitude"=latitude, "longitude"=longitude))
  simdata$treat <- NA
  
  for (i in 1:n) {# Identify "region" based on longitude
    closest_x <- which.min(abs(pointsALL[,"longitude"] - simdata$longitude[i]))
    
    # Region 1, 3, 5, 7: 1-26, 44-49, 66-73, 79-81
    # Longitude as a function of latitude
    if ((closest_x <= 26) | (closest_x >= 44 & closest_x <= 49) | 
        (closest_x >= 66 & closest_x <= 73) | (closest_x >= 79 & closest_x <= 81)) {
      # Find closest point (index) in terms of latitude in this region
      blocks <- list(c(1:26), c(44:49), c(66:73), c(79:81))
      for (j in 1:length(blocks)) {
        if (closest_x %in% blocks[[j]]) {region <- blocks[[j]]}}
      index1 <- which.min(abs(pointsALL[region,"latitude"] - simdata$latitude[i])) + region[1]-1
      if (pointsALL$latitude[index1] < simdata$latitude[i]){ 
        # simulation point is higher
        # index should decrease by 1 so latitude is bigger, fit a line between the 2 indices
        
        if (index1 == 1) { # Boundary situation, simply compare longitudes
          if (simdata$longitude[i] >= pointsALL$longitude[1]) {
            simdata$treat[i] <- 0}
          else {simdata$treat[i] <- 1}
        }
        
        else { # Not boundary, can subtract 1 to find the other index and fit a line
          index2 <- index1-1
          
          # Fitting a line (note: this is equivalent to "x as a function of y")
          slope_original <- (pointsALL$latitude[index1] - pointsALL$latitude[index2])/(pointsALL$longitude[index1] - pointsALL$longitude[index2])
          slope <- 1/slope_original
          intercept <- -(pointsALL$latitude[index1] - pointsALL$longitude[index1]*slope_original)/slope_original
          
          if (simdata$longitude[i] > simdata$latitude[i]*slope+intercept){
            # Simulation point is above the fitted line, not treated
            simdata$treat[i] <- 0
          }
          else{simdata$treat[i] <- 1}}
      }
      
      else {# simulation point is lower
        # index should increase by 1 so latitude is smaller, fit a line between the 2 indices
        index2 <- index1+1    # No boundary situation here
        
        # Fitting a line (note: this is equivalent to "x as a function of y")  
        slope_original <- (pointsALL$latitude[index1] - pointsALL$latitude[index2])/(pointsALL$longitude[index1] - pointsALL$longitude[index2])
        slope <- 1/slope_original
        intercept <- -(pointsALL$latitude[index1] - pointsALL$longitude[index1]*slope_original)/slope_original
        
        if (simdata$longitude[i] > simdata$latitude[i]*slope+intercept){
          simdata$treat[i] <- 0}
        else{simdata$treat[i] <- 1}}
    }
    
    # Region 2, 4, 6, 8: 26-44, 49-66, 73-79, 81-89
    # Latitude as a function of longitude
    if ((closest_x >= 26 & closest_x <= 44) | (closest_x >= 49 & closest_x <= 66) | 
        (closest_x >= 73 & closest_x <= 79) | (closest_x > 81 & closest_x <= 89)) {
      index1 <- closest_x
      
      if (pointsALL$longitude[index1] > simdata$longitude[i]){
        index2 <- index1-1
        slope <- (pointsALL$latitude[index1] - pointsALL$latitude[index2])/(pointsALL$longitude[index1] - pointsALL$longitude[index2])
        intercept <- pointsALL$latitude[index1] - pointsALL$longitude[index1]*slope
        
        if (simdata$latitude[i] > simdata$longitude[i]*slope+intercept) {
          simdata$treat[i] <- 0}
        else {simdata$treat[i] <- 1}}
      
      else {
        if (index1 == 89) { # Boundary situation here
          if (pointsALL$latitude[index1] < simdata$latitude[i]) {
            simdata$treat[i] <- 0}
          else {simdata$treat[i] <- 1}}
        
        else {
          index2 <- index1+1
          slope <- (pointsALL$latitude[index1] - pointsALL$latitude[index2])/(pointsALL$longitude[index1] - pointsALL$longitude[index2])
          intercept <- pointsALL$latitude[index1] - pointsALL$longitude[index1]*slope
          
          if (simdata$latitude[i] > simdata$longitude[i]*slope+intercept) {
            simdata$treat[i] <- 0}
          else {simdata$treat[i] <- 1}}
      }
    }
  }
  
  X1 <- simdata$latitude
  X2 <- simdata$longitude
  
  model.df <- data.frame(X1=X1, X1.2=(X1 - mean(X1))^2, X1.3=(X1 - mean(X1))^3,
                         X2=X2, X2.2=(X2 - mean(X2))^2, X2.3=(X2 - mean(X2))^3,
                         X12=(X1 - mean(X1))*(X2 - mean(X2)), 
                         W=simdata$treat)
  
  if (outcome=="turnout") {
    probs <- predict(cef, model.df, type = "response")
    simdata$e2008g <- sapply(probs, FUN=bern)
  }
  else if (outcome=="age") {
    simdata$age <- predict(cef, model.df)+rnorm(n,mean=0,sd=sigma_y)
  }
  else {
    simdata$price <- predict(cef, model.df)+rnorm(n,mean=0,sd=sigma_y)
  }
  return(simdata)
}

#### get_fit_draws is a function that generates a dataframe with num.params columns of runif values ####
### Argument: n_draws, which is the number of random combinations
get_fit_draws <- function(n_draws){
  unif <- runif(n_draws * num.params)
  fit_draws <- matrix(unif, n_draws, num.params,
                      dimnames = list(NULL, tune.parameters))
  return(fit_draws)
}

#### get_draw_parameters is a function that produces a dataframe with random draws of parameter values ####
### Arguments: fit_draws generated by get_fit_draws
get_draw_parameters <- function(fit_draws) {
  draw_parameters <- fit_draws
  draw_parameters[,1] <- draw_parameters[,1] / 5  # random alphas
  draw_parameters[,2] <- -log(draw_parameters[,2])  # random imbalance.penalties
  draw_parameters[,3] <- 0.5 + (0.8 - 0.5) * draw_parameters[,3]  # random honesty.fractions
  draw_parameters[,4] <- ifelse(draw_parameters[,4] < 0.5, TRUE, FALSE)  # random honesty.prune.leaves
  
  return(draw_parameters)
}

#### get_forest_debiased_error is a function that builds a forest using a particular combination of parameter values, and outputs that forest's mean squared debiased error ####
### Arguments: a row in the dataframe generated by draw_parameters, plus the number of trees and the type of the forest ("trt" or "ctrl")
get_forest_debiased_error <- function(param) {
  a <- as.double(param[1])
  imb <- as.double(param[2])
  h <- as.double(param[3])
  prune <- as.double(param[4])
  B <- as.numeric(param[5])
  type <- param[6]
  
  d <- ncol(feature_trt)  # dimension, same for trt and ctrl
  lower_bound <- (1+ (1/d)*log(1-a) / log(a))^(-1)
  
  if (type=="trt") {
    s <- scale*ceiling(nrow(trt)^lower_bound)/nrow(trt)
    forest <- regression_forest(feature_trt, trt[,4], mtry=1, num.trees=B, sample.fraction=s, honesty.fraction = h, alpha = a,
                                imbalance.penalty = imb, honesty.prune.leaves = prune)
    
  } else {
    s <- scale*ceiling(nrow(ctrl)^lower_bound)/nrow(ctrl)
    forest <- regression_forest(feature_ctrl, ctrl[,4], mtry=1, num.trees=B, sample.fraction=s, honesty.fraction = h, alpha = a,
                                imbalance.penalty = imb, honesty.prune.leaves = prune)
  }
  
  return(mean(forest$debiased.error, na.rm = TRUE))
}


#### get_kriging_model is a function that produces the Dice Kriging model for tuning ####
get_kriging_model <- function(fit_draws, small_forest_errors) {
  variance_guess <- rep(var(small_forest_errors) / 2, nrow(fit_draws))
  kriging_model <- tryCatch({
    capture.output(
      model <- km(
        design = data.frame(fit_draws),
        response = small_forest_errors,
        noise.var = variance_guess
      )
    )
    return(model)
  },
  error = function(e) {
    warning(paste0("Dicekriging threw the following error during forest tuning: \n", e))
    return(NULL)
  })
}
