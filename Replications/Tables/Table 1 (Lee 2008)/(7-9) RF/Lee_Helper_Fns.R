######################################
# Helper functions for Lee (2008)
# with univariate score
######################################
library(DiceKriging)
set.seed(1234)

#### get_fit_draws is a function that generates a dataframe with num.params columns of runif values ####
### Argument: n_draws, which is the number of random combinations
get_fit_draws <- function(n_draws){
  unif <- runif(n_draws * num.params)
  fit_draws <- matrix(unif, n_draws, num.params,
                      dimnames = list(NULL, tune.parameters))
  return(fit_draws)
}

#### get_draw_parameters is a function that produces a dataframe with random draws of parameter values ####
### Arguments: fit_draws generated by get_fit_draws
get_draw_parameters <- function(fit_draws) {
  draw_parameters <- fit_draws
  draw_parameters[,1] <- draw_parameters[,1] / 5  # random alphas
  draw_parameters[,2] <- -log(draw_parameters[,2])  # random imbalance.penalties
  draw_parameters[,3] <- 0.5 + (0.8 - 0.5) * draw_parameters[,3]  # random honesty.fractions
  draw_parameters[,4] <- ifelse(draw_parameters[,4] < 0.5, TRUE, FALSE)  # random honesty.prune.leaves

  return(draw_parameters)
}

#### get_forest_debiased_error is a function that builds a forest using a particular combination of parameter values, and outputs that forest's mean squared debiased error ####
### Arguments: a row in the dataframe generated by draw_parameters, plus the number of trees and the type of the forest ("trt" or "ctrl")
get_forest_debiased_error <- function(param) {
  a <- as.double(param[1])
  imb <- as.double(param[2])
  h <- as.double(param[3])
  prune <- as.double(param[4])
  B <- as.numeric(param[5])
  type <- param[6]
  lower_bound <- (1+ log(1-a) / log(a))^(-1)  # d=1

  if (type=="trt") {
    s <- scale*ceiling(nrow(trt)^lower_bound)/nrow(trt)
    forest <- regression_forest(feature_trt, trt$Y, mtry=1, num.trees=B, sample.fraction=s, honesty.fraction = h, alpha = a,
                                imbalance.penalty = imb, honesty.prune.leaves = prune)

  } else {
    s <- scale*ceiling(nrow(ctrl)^lower_bound)/nrow(ctrl)
    forest <- regression_forest(feature_ctrl, ctrl$Y, mtry=1, num.trees=B, sample.fraction=s, honesty.fraction = h, alpha = a,
                                imbalance.penalty = imb, honesty.prune.leaves = prune)
  }

  return(mean(forest$debiased.error, na.rm = TRUE))
}

#### get_kriging_model is a function that produces the Dice Kriging model for tuning ####
get_kriging_model <- function(fit_draws, small_forest_errors) {
  variance_guess <- rep(var(small_forest_errors) / 2, nrow(fit_draws))
  kriging_model <- tryCatch({
    capture.output(
      model <- km(
        design = data.frame(fit_draws),
        response = small_forest_errors,
        noise.var = variance_guess
      )
    )
    return(model)
  },
  error = function(e) {
    warning(paste0("Dicekriging threw the following error during forest tuning: \n", e))
    return(NULL)
  })
}
